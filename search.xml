<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>线性结构-稀疏数组</title>
    <url>/2021/02/16/%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84-%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h1 id="线性结构-稀疏数组"><a href="#线性结构-稀疏数组" class="headerlink" title="线性结构-稀疏数组"></a>线性结构-稀疏数组</h1><p>数据结构包括：<strong>线性结构</strong>和<strong>非线性结构</strong>。</p>
<h2 id="线性结构"><a href="#线性结构" class="headerlink" title="线性结构"></a>线性结构</h2><ol>
<li>线性结构作为最常用的数据结构，其特点是数据元素之间存在一对一的线性关系</li>
<li>线性结构有两种不同的存储结构，即顺序存储结构和链式存储结构。顺序存储的线性表称为顺序表，顺序表中的存储元素是连续的</li>
<li>链式存储的线性表称为链表，链表中的存储元素不一定是连续的，元素节点中存放数据元素以及相邻元素的地址信息</li>
<li>线性结构见的有：组队列、链表和栈</li>
</ol>
<h2 id="非线性结构"><a href="#非线性结构" class="headerlink" title="非线性结构"></a>非线性结构</h2><p>非线性结构包括：二维数组，多维数组，广义表，树结构，图结构</p>
<p>今天我们的主角是线性结构中的<code>稀疏数组</code>,今天讲解一下什么是稀疏数组，稀疏数组什么时候该用，以及怎么用。</p>
<h2 id="什么是稀疏数组"><a href="#什么是稀疏数组" class="headerlink" title="什么是稀疏数组"></a>什么是稀疏数组</h2><p>当一个数组中大部分元素为０，或者为同一个值的数组时，可以使用稀疏数组来保存该数组。用于减少存放这些数据使用的空间。</p>
<p>稀疏数组的处理方法是:</p>
<p>1)记录数组一共有几行几列，有多少个不同的值</p>
<p>2)把具有不同值的元素的行列及值记录在一个小规模的数组中，从而缩小程序的规模</p>
<p>用图说话：</p>
<p>原数组：（有很多0，这个时候可以选择稀疏数组进行压缩空间）</p>
<p><img src="https://i.loli.net/2021/02/16/y3WpCs6dKjVoMlv.png" alt="image.png"></p>
<p>稀疏数组：（第一行分别代表有6行，7列，以及有8个值，最终构成一个3列（8+1）行的二维数组）</p>
<p><img src="https://i.loli.net/2021/02/16/fZULtknmoxy4z6l.png" alt="image.png"></p>
<h2 id="稀疏数组怎么用"><a href="#稀疏数组怎么用" class="headerlink" title="稀疏数组怎么用"></a>稀疏数组怎么用</h2><p><img src="https://i.loli.net/2021/02/16/TmJCxNS5bVlgHPw.png" alt="image.png"></p>
<p>代码实现：原数组是一个11*11的二维数组</p>
<p><code>生成稀疏数组</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 生成稀疏数组</span><br><span class="line"> * @param cheeseArr</span><br><span class="line"> * @param sum</span><br><span class="line"> *&#x2F;</span><br><span class="line">private static int[][] generateSparseArray(int[][] cheeseArr, int sum) &#123;</span><br><span class="line">    &#x2F;&#x2F;2.创建对应的稀疏数组  一个3列 （非0项数字出现次数和+1）行 （多了一个统计原始数组行列和所有非0项出现次数和的行） 数组</span><br><span class="line">    int sparseArr[][] &#x3D; new int[sum +1][3];</span><br><span class="line">    &#x2F;&#x2F;给数组赋值</span><br><span class="line">    sparseArr[0][0] &#x3D; 11; &#x2F;&#x2F;行</span><br><span class="line">    sparseArr[0][1] &#x3D; 11; &#x2F;&#x2F;列</span><br><span class="line">    sparseArr[0][2] &#x3D; sum; &#x2F;&#x2F;有效值个数</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;便利二维数组，将非0值遍历到稀疏数组</span><br><span class="line">    &#x2F;&#x2F;定义一个计数器，记录是第几个数</span><br><span class="line">    int count  &#x3D; 0;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; cheeseArr.length; i++) &#123;</span><br><span class="line">        for (int j &#x3D; 0; j &lt; cheeseArr[i].length; j++) &#123;</span><br><span class="line">            if(cheeseArr[i][j]!&#x3D;0) &#123;</span><br><span class="line">                count++;</span><br><span class="line">                sparseArr[count][0] &#x3D; i; &#x2F;&#x2F;行</span><br><span class="line">                sparseArr[count][1] &#x3D; j; &#x2F;&#x2F;列</span><br><span class="line">                sparseArr[count][2] &#x3D; cheeseArr[i][j]; &#x2F;&#x2F;值</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;输出稀疏数组</span><br><span class="line">    System.out.println();</span><br><span class="line">    System.out.println(&quot;得到的稀疏数组为:&quot;);</span><br><span class="line">    for (int i &#x3D; 0; i &lt; sparseArr.length; i++) &#123;</span><br><span class="line">        System.out.printf(&quot;%d\t %d\t %d\t&quot;,sparseArr[i][0],sparseArr[i][1],sparseArr[i][2]);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">    return sparseArr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>解析稀疏数组</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">     * 通过稀疏数组还原原数组</span><br><span class="line">     * 思路：先读取第一行数据，创建原始的二维数组</span><br><span class="line">     * 读取稀疏数组后几行数据并赋值给原始的二维数组即可</span><br><span class="line">     * @param sparseArr</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static int[][] getOriginArr(int[][] sparseArr)&#123;</span><br><span class="line">        int[][] originArray &#x3D; new int[sparseArr[0][0]][sparseArr[0][1]];</span><br><span class="line">        for (int i &#x3D; 1; i &lt; sparseArr.length; i++) &#123;</span><br><span class="line">            originArray[sparseArr[i][0]][sparseArr[i][1]] &#x3D; sparseArr[i][2];</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;原始数组为:&quot;);</span><br><span class="line">        for (int i &#x3D; 0; i &lt; originArray.length; i++) &#123;</span><br><span class="line">            for (int j &#x3D; 0; j &lt; originArray[i].length; j++) &#123;</span><br><span class="line">                System.out.printf(&quot;%d\t&quot;,originArray[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        return originArray;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>总的代码为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package top.ryan.sparsearray;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 稀疏数组</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class SparseArray &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;创建一个原始的二维数组11*11</span><br><span class="line">        &#x2F;&#x2F;0-》没有棋子 1-》黑子 2-》蓝子</span><br><span class="line">        int cheeseArr[][] &#x3D; new int[11][11];</span><br><span class="line">        cheeseArr[1][2] &#x3D; 1;</span><br><span class="line">        cheeseArr[2][3] &#x3D; 2;</span><br><span class="line">        cheeseArr[3][3] &#x3D; 1;</span><br><span class="line">        cheeseArr[4][5] &#x3D; 2;</span><br><span class="line">        &#x2F;&#x2F;输出原始数组</span><br><span class="line">        for (int[] arr : cheeseArr) &#123;</span><br><span class="line">            for (int num : arr) &#123;</span><br><span class="line">                System.out.printf(&quot;%d\t&quot;,num);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;将二维数组转为稀疏数组</span><br><span class="line">        &#x2F;&#x2F;1.先便利二维数组，得到非0数组的个数</span><br><span class="line">        int sum &#x3D; 0;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; cheeseArr.length; i++) &#123;</span><br><span class="line">            for (int j &#x3D; 0; j &lt; cheeseArr[i].length; j++) &#123;</span><br><span class="line">                if(cheeseArr[i][j]!&#x3D;0)&#123;</span><br><span class="line">                    sum++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int[][] sparseArr &#x3D; generateSparseArray(cheeseArr, sum);</span><br><span class="line">        &#x2F;&#x2F;从稀疏数组还原原始数组</span><br><span class="line">        int[][] originArr &#x3D; getOriginArr(sparseArr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 生成稀疏数组</span><br><span class="line">     * @param cheeseArr</span><br><span class="line">     * @param sum</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private static int[][] generateSparseArray(int[][] cheeseArr, int sum) &#123;</span><br><span class="line">        &#x2F;&#x2F;2.创建对应的稀疏数组  一个3列 （非0项数字出现次数和+1）行 （多了一个统计原始数组行列和所有非0项出现次数和的行） 数组</span><br><span class="line">        int sparseArr[][] &#x3D; new int[sum +1][3];</span><br><span class="line">        &#x2F;&#x2F;给数组赋值</span><br><span class="line">        sparseArr[0][0] &#x3D; 11; &#x2F;&#x2F;行</span><br><span class="line">        sparseArr[0][1] &#x3D; 11; &#x2F;&#x2F;列</span><br><span class="line">        sparseArr[0][2] &#x3D; sum; &#x2F;&#x2F;有效值个数</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;便利二维数组，将非0值遍历到稀疏数组</span><br><span class="line">        &#x2F;&#x2F;定义一个计数器，记录是第几个数</span><br><span class="line">        int count  &#x3D; 0;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; cheeseArr.length; i++) &#123;</span><br><span class="line">            for (int j &#x3D; 0; j &lt; cheeseArr[i].length; j++) &#123;</span><br><span class="line">                if(cheeseArr[i][j]!&#x3D;0) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                    sparseArr[count][0] &#x3D; i; &#x2F;&#x2F;行</span><br><span class="line">                    sparseArr[count][1] &#x3D; j; &#x2F;&#x2F;列</span><br><span class="line">                    sparseArr[count][2] &#x3D; cheeseArr[i][j]; &#x2F;&#x2F;值</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;输出稀疏数组</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(&quot;得到的稀疏数组为:&quot;);</span><br><span class="line">        for (int i &#x3D; 0; i &lt; sparseArr.length; i++) &#123;</span><br><span class="line">            System.out.printf(&quot;%d\t %d\t %d\t&quot;,sparseArr[i][0],sparseArr[i][1],sparseArr[i][2]);</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        return sparseArr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 通过稀疏数组还原原数组</span><br><span class="line">     * 思路：先读取第一行数据，创建原始的二维数组</span><br><span class="line">     * 读取稀疏数组后几行数据并赋值给原始的二维数组即可</span><br><span class="line">     * @param sparseArr</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static int[][] getOriginArr(int[][] sparseArr)&#123;</span><br><span class="line">        int[][] originArray &#x3D; new int[sparseArr[0][0]][sparseArr[0][1]];</span><br><span class="line">        for (int i &#x3D; 1; i &lt; sparseArr.length; i++) &#123;</span><br><span class="line">            originArray[sparseArr[i][0]][sparseArr[i][1]] &#x3D; sparseArr[i][2];</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;原始数组为:&quot;);</span><br><span class="line">        for (int i &#x3D; 0; i &lt; originArray.length; i++) &#123;</span><br><span class="line">            for (int j &#x3D; 0; j &lt; originArray[i].length; j++) &#123;</span><br><span class="line">                System.out.printf(&quot;%d\t&quot;,originArray[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        return originArray;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0	0	0	0	0	0	0	0	0	0	0	</span><br><span class="line">0	0	1	0	0	0	0	0	0	0	0	</span><br><span class="line">0	0	0	2	0	0	0	0	0	0	0	</span><br><span class="line">0	0	0	1	0	0	0	0	0	0	0	</span><br><span class="line">0	0	0	0	0	2	0	0	0	0	0	</span><br><span class="line">0	0	0	0	0	0	0	0	0	0	0	</span><br><span class="line">0	0	0	0	0	0	0	0	0	0	0	</span><br><span class="line">0	0	0	0	0	0	0	0	0	0	0	</span><br><span class="line">0	0	0	0	0	0	0	0	0	0	0	</span><br><span class="line">0	0	0	0	0	0	0	0	0	0	0	</span><br><span class="line">0	0	0	0	0	0	0	0	0	0	0	</span><br><span class="line"></span><br><span class="line">得到的稀疏数组为:</span><br><span class="line">11	 11	 4	</span><br><span class="line">1	 2	 1	</span><br><span class="line">2	 3	 2	</span><br><span class="line">3	 3	 1	</span><br><span class="line">4	 5	 2	</span><br><span class="line">原始数组为:</span><br><span class="line">0	0	0	0	0	0	0	0	0	0	0	</span><br><span class="line">0	0	1	0	0	0	0	0	0	0	0	</span><br><span class="line">0	0	0	2	0	0	0	0	0	0	0	</span><br><span class="line">0	0	0	1	0	0	0	0	0	0	0	</span><br><span class="line">0	0	0	0	0	2	0	0	0	0	0	</span><br><span class="line">0	0	0	0	0	0	0	0	0	0	0	</span><br><span class="line">0	0	0	0	0	0	0	0	0	0	0	</span><br><span class="line">0	0	0	0	0	0	0	0	0	0	0	</span><br><span class="line">0	0	0	0	0	0	0	0	0	0	0	</span><br><span class="line">0	0	0	0	0	0	0	0	0	0	0	</span><br><span class="line">0	0	0	0	0	0	0	0	0	0	0	</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>线性结构-链表应用</title>
    <url>/2021/02/18/%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<h1 id="线性结构-链表应用"><a href="#线性结构-链表应用" class="headerlink" title="线性结构-链表应用"></a>线性结构-链表应用</h1><h2 id="pr1-获取链表有效长度"><a href="#pr1-获取链表有效长度" class="headerlink" title="pr1 获取链表有效长度"></a>pr1 获取链表有效长度</h2><p>思路：判空之后，定义计数器，遍历链表到链表末尾，返回计数器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">前提：还是使用 线性结构-链表 文章中的HeroNode类</span><br><span class="line">&#x2F;&#x2F;定义一个heroNode</span><br><span class="line">class HeroNode&#123;</span><br><span class="line">    &#x2F;&#x2F;编号</span><br><span class="line">    public int no;</span><br><span class="line">    &#x2F;&#x2F;英雄名字</span><br><span class="line">    public String name;</span><br><span class="line">    &#x2F;&#x2F;英雄昵称</span><br><span class="line">    public String nickName;</span><br><span class="line">    &#x2F;&#x2F;指向的下一个英雄</span><br><span class="line">    public HeroNode next;</span><br><span class="line"></span><br><span class="line">    public HeroNode(int no,String name,String nickName)&#123;</span><br><span class="line">        this.no &#x3D; no;</span><br><span class="line">        this.nickName &#x3D; nickName;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String  toString() &#123;</span><br><span class="line">        return &quot;HeroNode&#123;&quot; +</span><br><span class="line">                &quot;no&#x3D;&quot; + no +</span><br><span class="line">                &quot;, name&#x3D;&#39;&quot; + name + &#39;\&#39;&#39; +</span><br><span class="line">                &quot;, nickName&#x3D;&#39;&quot; + nickName + &#39;\&#39;&#39; +</span><br><span class="line">                &#39;&#125;&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">    * 获取链表有效长度</span><br><span class="line">    * @return</span><br><span class="line">    *&#x2F;</span><br><span class="line">   public int getValidLength()&#123;</span><br><span class="line">       &#x2F;&#x2F;判空,可以不判，但是判空之后如果满足条件直接就不用执行后面的了</span><br><span class="line">       if(head.next&#x3D;&#x3D;null)&#123;</span><br><span class="line">           return 0;</span><br><span class="line">       &#125;</span><br><span class="line">       &#x2F;&#x2F;定义辅助变量遍历链表</span><br><span class="line">       HeroNode temp &#x3D; head.next;</span><br><span class="line">       &#x2F;&#x2F;定义计数器</span><br><span class="line">       int count &#x3D; 0;</span><br><span class="line">       &#x2F;&#x2F;遍历</span><br><span class="line">       while (temp !&#x3D; null) &#123;</span><br><span class="line">           &#x2F;&#x2F;计数器累加</span><br><span class="line">           count++;</span><br><span class="line">           &#x2F;&#x2F;后移</span><br><span class="line">           temp &#x3D; temp.next;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       return count;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h2 id="pr2获取倒数第k个元素"><a href="#pr2获取倒数第k个元素" class="headerlink" title="pr2获取倒数第k个元素"></a>pr2获取倒数第k个元素</h2><p>思路：遍历链表查找有效值个数；在遍历一次size=(count-k) || 快慢指针，这里只讲链表</p>
<p>代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 查找单链表中倒数第k个节点</span><br><span class="line"> * 思路：遍历链表查找有效值个数；在遍历一次size&#x3D;(count-k)</span><br><span class="line"> *</span><br><span class="line"> * @param k 倒数第k个</span><br><span class="line"> * @return</span><br><span class="line"> *&#x2F;</span><br><span class="line">public HeroNode getLastKthNode(int k) &#123;</span><br><span class="line">    &#x2F;&#x2F;判空</span><br><span class="line">    if(head.next&#x3D;&#x3D;null)&#123;</span><br><span class="line">        System.out.println(&quot;链表为空&quot;);</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;遍历找到有效值个数</span><br><span class="line">    int count &#x3D; getValidLength();</span><br><span class="line">    &#x2F;&#x2F;定义辅助变量</span><br><span class="line">    HeroNode temp &#x3D; head.next;</span><br><span class="line">    &#x2F;&#x2F;寻找边界值</span><br><span class="line">    if (k &lt;&#x3D; 0 || k &gt; count) &#123;</span><br><span class="line">        System.out.println(&quot;k小于0或大于链表有效值个数&quot;);</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;遍历</span><br><span class="line">    for (int i &#x3D; 0; i &lt; (count - k); i++) &#123;</span><br><span class="line">        temp &#x3D; temp.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;没找到返回null</span><br><span class="line">    return temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class SingleLinkedListDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;测试</span><br><span class="line">        HeroNode heroNode1 &#x3D; new HeroNode(1,&quot;宋江&quot;,&quot;及时雨&quot;);</span><br><span class="line">        HeroNode heroNode2 &#x3D; new HeroNode(2,&quot;卢俊义&quot;,&quot;玉麒麟&quot;);</span><br><span class="line">        HeroNode heroNode3 &#x3D; new HeroNode(3,&quot;吴用&quot;,&quot;智多星&quot;);</span><br><span class="line">        HeroNode heroNode4 &#x3D; new HeroNode(4,&quot;林冲&quot;,&quot;豹子头&quot;);</span><br><span class="line">        HeroNode heroNode5 &#x3D; new HeroNode(5,&quot;张飞&quot;,&quot;黑旋风&quot;);</span><br><span class="line">        SingleLinkedList singleLinkedList1 &#x3D; new SingleLinkedList();</span><br><span class="line">        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);</span><br><span class="line">        singleLinkedList1.addNodeInOrder(heroNode1);</span><br><span class="line">        singleLinkedList1.addNodeInOrder(heroNode3);</span><br><span class="line">        singleLinkedList1.addNodeInOrder(heroNode2);</span><br><span class="line">        singleLinkedList1.addNodeInOrder(heroNode5);</span><br><span class="line">        singleLinkedList1.addNodeInOrder(heroNode4);</span><br><span class="line">        singleLinkedList1.showNode();</span><br><span class="line">        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);</span><br><span class="line">        int validLength &#x3D; singleLinkedList1.getValidLength();</span><br><span class="line">        System.out.println(&quot;有效长度为&quot;+validLength);</span><br><span class="line">        int k &#x3D; 2;</span><br><span class="line">        HeroNode lastKthNode &#x3D; singleLinkedList1.getLastKthNode(k);</span><br><span class="line">        System.out.println(&quot;倒数第&quot;+k+&quot;个元素为:&quot;+lastKthNode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HeroNode&#123;no&#x3D;1, name&#x3D;&#39;宋江&#39;, nickName&#x3D;&#39;及时雨&#39;&#125;</span><br><span class="line">HeroNode&#123;no&#x3D;2, name&#x3D;&#39;卢俊义&#39;, nickName&#x3D;&#39;玉麒麟&#39;&#125;</span><br><span class="line">HeroNode&#123;no&#x3D;3, name&#x3D;&#39;吴用&#39;, nickName&#x3D;&#39;智多星&#39;&#125;</span><br><span class="line">HeroNode&#123;no&#x3D;4, name&#x3D;&#39;林冲&#39;, nickName&#x3D;&#39;豹子头&#39;&#125;</span><br><span class="line">HeroNode&#123;no&#x3D;5, name&#x3D;&#39;张飞&#39;, nickName&#x3D;&#39;黑旋风&#39;&#125;</span><br><span class="line">有效长度为5</span><br><span class="line">倒数第2个元素为:HeroNode&#123;no&#x3D;4, name&#x3D;&#39;林冲&#39;, nickName&#x3D;&#39;豹子头&#39;&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-141.环形链表</title>
    <url>/2021/02/19/leetcode-141-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="leetcode-141-环形链表"><a href="#leetcode-141-环形链表" class="headerlink" title="leetcode-141. 环形链表"></a>leetcode-<a href="https://leetcode-cn.com/problems/linked-list-cycle/">141. 环形链表</a></h1><p>给定一个链表，判断链表中是否有环。</p>
<p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。</p>
<p>如果链表中存在环，则返回 true 。 否则，返回 false 。</p>
<p>示例 1：</p>
<p> <img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png" alt="img">  </p>
<p>输入：head = [3,2,0,-4], pos = 1<br>输出：true<br>解释：链表中有一个环，其尾部连接到第二个节点。<br>示例 2：</p>
<p> <img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png" alt="img"></p>
<p>输入：head = [1,2], pos = 0<br>输出：true<br>解释：链表中有一个环，其尾部连接到第一个节点。<br>示例 3：</p>
<p> <img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png" alt="img"></p>
<p>输入：head = [1], pos = -1<br>输出：false<br>解释：链表中没有环。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/linked-list-cycle">https://leetcode-cn.com/problems/linked-list-cycle</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<p>这是一道链表相关的题：</p>
<p>首先我第一眼看到这题，想到的思路是：一个个遍历，然后判断是否出现过重复的节点，如果出现过那么肯定存在环，不然就不存在</p>
<p>代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class CircleLinkedList &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ListNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode(int x) &#123;</span><br><span class="line">        val &#x3D; x;</span><br><span class="line">        next &#x3D; null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 遍历所有节点，每遍历一次就判断一次是否添加过</span><br><span class="line"> *&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public boolean hasCycle(ListNode head) &#123;</span><br><span class="line">        Set&lt;ListNode&gt; set &#x3D; new HashSet&lt;&gt;();</span><br><span class="line">        while (head!&#x3D;null)&#123;</span><br><span class="line">        	&#x2F;&#x2F;保存在set集合中，并判断是否在集合中出现过</span><br><span class="line">            if(!set.add(head))&#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;后移</span><br><span class="line">            head &#x3D; head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用时比较长，是一种常规解法，后来学习到可以使用 <code>快慢指针</code>来解决这题，效率很高，具体思路：</p>
<p><code>定义2个指针，一个步长为1 ，一个步长为2，让他们跑，如果有环，他们肯定会相遇，没有环就不会相遇</code></p>
<p>代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;快慢指针</span><br><span class="line">    &#x2F;*</span><br><span class="line">    * 我们定义两个指针，一快一满。慢指针每次只移动一步，而快指针每次移动两步。初始时，慢指针在位置 head，</span><br><span class="line">    * 而快指针在位置 head.next。这样一来，如果在移动的过程中，快指针反过来追上慢指针，就说明该链表为环形链表。</span><br><span class="line">    * 否则快指针将到达链表尾部，该链表不为环形链表。</span><br><span class="line">    * *&#x2F;</span><br><span class="line">class Solution&#123;</span><br><span class="line">    public boolean hasCycle(ListNode head) &#123;</span><br><span class="line">        &#x2F;&#x2F;判空</span><br><span class="line">        if(head&#x3D;&#x3D;null||head.next&#x3D;&#x3D;null)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;定义满指针</span><br><span class="line">        ListNode slow &#x3D; head;</span><br><span class="line">        &#x2F;&#x2F;定义快指针</span><br><span class="line">        ListNode fast &#x3D; head.next;</span><br><span class="line">        while (slow!&#x3D;fast)&#123;</span><br><span class="line">        	&#x2F;&#x2F;判断是否已经遍历完了链表，遍历完了链表说明不可能有环的存在</span><br><span class="line">            if (fast &#x3D;&#x3D; null || fast.next &#x3D;&#x3D; null) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            slow &#x3D; slow.next;</span><br><span class="line">            fast &#x3D; fast.next.next;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>线性结构-队列</title>
    <url>/2021/02/18/%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84-%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h1 id="线性结构-队列"><a href="#线性结构-队列" class="headerlink" title="线性结构-队列"></a>线性结构-队列</h1><p>队列是一个有序列表，可以用<strong>数组</strong>或是<strong>链表</strong>来实现。</p>
<p>遵循<strong>先入先出</strong>的原则。即：先存入队列的数据，要先取出。后存入的要后取出</p>
<p>使用数组模拟队列示意图</p>
<p><img src="https://i.loli.net/2021/02/17/2JuWlZzhMgNGYnx.png" alt="image.png"></p>
<h2 id="数组模拟队列"><a href="#数组模拟队列" class="headerlink" title="数组模拟队列"></a>数组模拟队列</h2><p>​        队列本身是有序列表，若使用数组的结构来存储队列的数据，则队列数组的声明如下图, 其中 maxSize 是该队列的最大容量。</p>
<p>​     因为队列的输出、输入是分别从前后端来处理，因此需要两个变<strong>量</strong> <strong>front**</strong>及** <strong>rear**</strong>分别记录队列前后端**的下标，front 会随着数据输出而改变，而 rear则是随着数据输入而改变</p>
<p><img src="https://i.loli.net/2021/02/17/yVlDkTzdxcFAL2h.png" alt="image.png"></p>
<p>模拟队列思路：</p>
<p>当我们将数据存入队列时称为”addQueue”，addQueue 的处理需要有两个步骤：<strong>思**</strong>路分析** </p>
<p>1)将尾指针往后移：rear+1 , 当front == rear 【空】</p>
<p>2)若尾指针 rear 小于队列的最大下标 maxSize-1，则将数据存入 rear所指的数组元素中，否则无法存入数据。 rear == maxSize - 1[队列满] </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class ArrayQueue(arrMaxSize: Int) &#123; val maxSize: Int &#x3D; arrMaxSize</span><br><span class="line">  val array &#x3D; new Array[Int](arrMaxSize)</span><br><span class="line">  var front: Int &#x3D; -1</span><br><span class="line">  var rear: Int &#x3D; -1</span><br><span class="line">&#125;</span><br><span class="line">rear 是队列最后[含]</span><br><span class="line">front 是队列最前元素[不含]</span><br></pre></td></tr></table></figure>
<p>Ø出队列操作popQueue</p>
<p>入队列操作addQueue</p>
<p>Ø显示队列的情况showQueue</p>
<p>Ø查看队列头元素<strong>head</strong>Queue</p>
<p>代码实现数组模拟队列：(初始代码)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Queue&#123;</span><br><span class="line">    &#x2F;&#x2F;队头</span><br><span class="line">    private int front;</span><br><span class="line">    &#x2F;&#x2F;队尾</span><br><span class="line">    private int rear;</span><br><span class="line">    &#x2F;&#x2F;初始化一个6个size的数组</span><br><span class="line">    private int[] arr;</span><br><span class="line">    private int maxSize;</span><br><span class="line"></span><br><span class="line">    public Queue(int size)&#123;</span><br><span class="line">        if (size&lt;1)&#123;</span><br><span class="line">            throw new RuntimeException(&quot;数组大小不能小于1&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        maxSize &#x3D; size;</span><br><span class="line">        arr &#x3D; new int[maxSize];</span><br><span class="line">        front &#x3D; -1;</span><br><span class="line">        rear &#x3D; -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 队尾添加数字,如果rear&lt;size-1就可以继续添加，不然</span><br><span class="line">     * @param num</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void addQueue(int num)&#123;</span><br><span class="line">        if (isFull())&#123;</span><br><span class="line">            System.out.println(&quot;队列已满，不能添加&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[rear+1] &#x3D; num;</span><br><span class="line">        rear++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 弹出队头</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public int popQueue()&#123;</span><br><span class="line">        if(isEmpty())&#123;</span><br><span class="line">            throw new RuntimeException(&quot;队列为空，不能弹出队列&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        int headNum &#x3D; arr[front+1];</span><br><span class="line">        front++;</span><br><span class="line">        System.out.println(&quot;弹出元素: &quot;+headNum);</span><br><span class="line">        return headNum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 显示队列</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void showQueue()&#123;</span><br><span class="line">        if(isEmpty())&#123;</span><br><span class="line">            System.out.println(&quot;队列为空&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i &#x3D; front+1 ; i &lt;&#x3D; rear; i++) &#123;</span><br><span class="line">            System.out.printf(&quot;%d\t&quot;,arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 显示队头</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void headQueue()&#123;</span><br><span class="line">        if(isEmpty())&#123;</span><br><span class="line">            System.out.println(&quot;队列为空&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;队头元素:&quot;+arr[front+1]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 显示队尾</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void rearQueue()&#123;</span><br><span class="line">        if(isEmpty())&#123;</span><br><span class="line">            System.out.println(&quot;队列为空&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;队尾元素:&quot;+arr[rear]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 队列是否满 队尾&#x3D;maxsize-1</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public boolean isFull()&#123;</span><br><span class="line">        if (rear&#x3D;&#x3D;maxSize-1)&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 队列是否时空的 队尾&#x3D;队头&#x3D;-1则为空</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public boolean isEmpty()&#123;</span><br><span class="line">        if(front&#x3D;&#x3D;rear)&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ArrayQueue &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Queue queue &#x3D; new Queue(5);</span><br><span class="line">        queue.addQueue(1);</span><br><span class="line">        queue.addQueue(2);</span><br><span class="line">        queue.addQueue(3);</span><br><span class="line">        queue.addQueue(4);</span><br><span class="line">        queue.addQueue(5);</span><br><span class="line">        queue.showQueue();</span><br><span class="line">        queue.headQueue();</span><br><span class="line">        queue.rearQueue();</span><br><span class="line">        queue.popQueue();</span><br><span class="line">        queue.showQueue();</span><br><span class="line">        queue.headQueue();</span><br><span class="line">        queue.rearQueue();</span><br><span class="line">        queue.popQueue();</span><br><span class="line">        queue.popQueue();</span><br><span class="line">        queue.popQueue();</span><br><span class="line">        queue.popQueue();</span><br><span class="line">        queue.popQueue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1	2	3	4	5	</span><br><span class="line">队头元素:1</span><br><span class="line">队尾元素:5</span><br><span class="line">弹出元素: 1</span><br><span class="line">2	3	4	5	</span><br><span class="line">队头元素:2</span><br><span class="line">队尾元素:5</span><br><span class="line">弹出元素: 2</span><br><span class="line">弹出元素: 3</span><br><span class="line">弹出元素: 4</span><br><span class="line">弹出元素: 5</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.RuntimeException: 队列为空，不能弹出队列</span><br></pre></td></tr></table></figure>
<p>可以看到，基本能完成队列的功能，但是有问题，<code>数组不能复用</code>，空间满了就不能继续添加了，现在进行优化，使用数组模拟环形队列，解决数组不能复用的问题。</p>
<h2 id="数组模拟环形队列"><a href="#数组模拟环形队列" class="headerlink" title="数组模拟环形队列"></a>数组模拟环形队列</h2><p>使用数组模拟环形队列思路：</p>
<p><img src="https://i.loli.net/2021/02/17/yVlDkTzdxcFAL2h.png" alt="image.png"></p>
<p>代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 使用数组实现环形队列 ：用以实现数组复用</span><br><span class="line"> * 这里做了2个调整：front指向第一个元素所在位置  rear指向最后一个元素所在位置</span><br><span class="line"> * 数组中有效个数为：(rear + maxsize - front) % maxsize</span><br><span class="line"> *&#x2F;</span><br><span class="line">class CircleQueue&#123;</span><br><span class="line">    &#x2F;&#x2F;第一个元素所在位置</span><br><span class="line">    private int front;</span><br><span class="line">    &#x2F;&#x2F;最后一个元素所在位置</span><br><span class="line">    private int rear;</span><br><span class="line">    &#x2F;&#x2F;最大容量</span><br><span class="line">    private int maxsize;</span><br><span class="line">    &#x2F;&#x2F;数组</span><br><span class="line">    private int[] arr;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 初始化环形队列</span><br><span class="line">     * @param size 最大容量</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public CircleQueue(int size)&#123;</span><br><span class="line">        front &#x3D; 0; &#x2F;&#x2F;第一个位置</span><br><span class="line">        rear &#x3D; 0; &#x2F;&#x2F;最开始也为0</span><br><span class="line">        maxsize &#x3D; size;</span><br><span class="line">        arr &#x3D; new int[maxsize];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 添加队列元素</span><br><span class="line">     * @param num</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void addQueue(int num)&#123;</span><br><span class="line">        if (isFull()) &#123;</span><br><span class="line">            System.out.println(&quot;队列已满，不能添加数据&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[rear] &#x3D; num;</span><br><span class="line">        rear &#x3D; (rear+1)%maxsize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 取出数据</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public int popQueue()&#123;</span><br><span class="line">        if (isEmpty()) &#123;</span><br><span class="line">            throw new RuntimeException(&quot;队列为空...&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        int num &#x3D; arr[front];</span><br><span class="line">        front &#x3D; (front+1)%maxsize;</span><br><span class="line">        return num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 显示队列,front是会不断累加的会有溢出，需要取模</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void showQueue()&#123;</span><br><span class="line">        if (isEmpty())&#123;</span><br><span class="line">            System.out.println(&quot;队列为空&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i &#x3D; front; i &lt; front+getSize(); i++) &#123;</span><br><span class="line">            System.out.printf(&quot;arr[%d] &#x3D; %d \t&quot;,i%maxsize,arr[i%maxsize]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 队列是否为空： 判断条件 front  &#x3D; rear</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public boolean isEmpty()&#123;</span><br><span class="line">        return rear &#x3D;&#x3D; front;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 队列是否满：条件 （rear + 1）%maxsize &#x3D; front;eg:rear&#x3D;9,maxsize&#x3D;10,front&#x3D;0,数组下标最大就为9，9+1%10 &#x3D;0 &#x3D; front</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public boolean isFull()&#123;</span><br><span class="line">         return (rear+1)%maxsize&#x3D;&#x3D;front;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 获取队列有效个数</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public int getSize()&#123;</span><br><span class="line">        return (maxsize + rear - front)%maxsize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title>链表应用-头插法反转链表</title>
    <url>/2021/02/19/%E9%93%BE%E8%A1%A8%E5%BA%94%E7%94%A8-%E5%A4%B4%E6%8F%92%E6%B3%95%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="链表应用-头插法反转链表"><a href="#链表应用-头插法反转链表" class="headerlink" title="链表应用-头插法反转链表"></a>链表应用-头插法反转链表</h1><p>思路：</p>
<p>   1.先定义一个节点reverseHead = new HeroNode()</p>
<ol start="2">
<li><p>从头到位遍历链表，每遍历一个元素就摘下该元素然后放在链表reverseHead的最前端</p>
</li>
<li><p>用原来的链表替换新的链表：head.next = reverseHead.next</p>
<p>图示意：</p>
</li>
</ol>
<p><img src="https://i.loli.net/2021/02/18/V1GJWHQRqlT7nwD.png" alt="image.png"></p>
<p>使用头插法之后：</p>
<p><img src="https://i.loli.net/2021/02/18/iOzpgCf5LdRXGyW.png" alt="image.png"></p>
<p><img src="https://i.loli.net/2021/02/18/jm2F1u4UodnwAYh.png" alt="image.png"></p>
<p>代码实现：</p>
<p>前提：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;定义一个heroNode</span><br><span class="line">class HeroNode&#123;</span><br><span class="line">    &#x2F;&#x2F;编号</span><br><span class="line">    public int no;</span><br><span class="line">    &#x2F;&#x2F;英雄名字</span><br><span class="line">    public String name;</span><br><span class="line">    &#x2F;&#x2F;英雄昵称</span><br><span class="line">    public String nickName;</span><br><span class="line">    &#x2F;&#x2F;指向的下一个英雄</span><br><span class="line">    public HeroNode next;</span><br><span class="line"></span><br><span class="line">    public HeroNode(int no,String name,String nickName)&#123;</span><br><span class="line">        this.no &#x3D; no;</span><br><span class="line">        this.nickName &#x3D; nickName;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String  toString() &#123;</span><br><span class="line">        return &quot;HeroNode&#123;&quot; +</span><br><span class="line">                &quot;no&#x3D;&quot; + no +</span><br><span class="line">                &quot;, name&#x3D;&#39;&quot; + name + &#39;\&#39;&#39; +</span><br><span class="line">                &quot;, nickName&#x3D;&#39;&quot; + nickName + &#39;\&#39;&#39; +</span><br><span class="line">                &#39;&#125;&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>翻转链表思路：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">     * 反转链表：头插法</span><br><span class="line">     * 思路：先定义一个节点reverseHead &#x3D; new HeroNode()</span><br><span class="line">     * 从头到位遍历链表，每遍历一个元素就摘下该元素然后放在链表reverseHead的最前端</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void reverseLinkedList()&#123;</span><br><span class="line">        HeroNode reverseHead &#x3D; new HeroNode(0,&quot;&quot;,&quot;&quot;);</span><br><span class="line">        &#x2F;&#x2F;判空</span><br><span class="line">        if(head.next &#x3D;&#x3D;null)&#123;</span><br><span class="line">            System.out.println(&quot;链表为空&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;定义辅助变量</span><br><span class="line">        HeroNode temp &#x3D; head.next;</span><br><span class="line">        &#x2F;&#x2F;遍历链表</span><br><span class="line">        while (temp!&#x3D;null)&#123;</span><br><span class="line">            &#x2F;&#x2F;把这个节点摘下，然后插入反转链表最前面</span><br><span class="line">            head.next &#x3D; temp.next;</span><br><span class="line">            temp.next &#x3D;null;</span><br><span class="line">            &#x2F;&#x2F;把这个值插入到反转链表头部</span><br><span class="line">            if(reverseHead.next!&#x3D;null)&#123;</span><br><span class="line">                temp.next &#x3D; reverseHead.next;</span><br><span class="line">                reverseHead.next &#x3D; temp;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                reverseHead.next &#x3D; temp;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;后移,因为temp节点已经被摘掉了，所以head节点下一个节点就是第二个节点</span><br><span class="line">            temp &#x3D; head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;得到了反转链表reverseHead,然后替换原来的链表</span><br><span class="line">        head.next &#x3D; reverseHead.next;</span><br><span class="line">        &#x2F;&#x2F;遍历head</span><br><span class="line">        HeroNode temp1 &#x3D; head.next;</span><br><span class="line">        while (temp1!&#x3D;null)&#123;</span><br><span class="line">            System.out.println(temp1);</span><br><span class="line">            temp1 &#x3D; temp1.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>测试demo:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class SingleLinkedListDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;测试</span><br><span class="line">        HeroNode heroNode1 &#x3D; new HeroNode(1,&quot;宋江&quot;,&quot;及时雨&quot;);</span><br><span class="line">        HeroNode heroNode2 &#x3D; new HeroNode(2,&quot;卢俊义&quot;,&quot;玉麒麟&quot;);</span><br><span class="line">        HeroNode heroNode3 &#x3D; new HeroNode(3,&quot;吴用&quot;,&quot;智多星&quot;);</span><br><span class="line">        HeroNode heroNode4 &#x3D; new HeroNode(4,&quot;林冲&quot;,&quot;豹子头&quot;);</span><br><span class="line">        HeroNode heroNode5 &#x3D; new HeroNode(5,&quot;张飞&quot;,&quot;黑旋风&quot;);</span><br><span class="line">        singleLinkedList1.addNodeInOrder(heroNode1);</span><br><span class="line">        singleLinkedList1.addNodeInOrder(heroNode3);</span><br><span class="line">        singleLinkedList1.addNodeInOrder(heroNode2);</span><br><span class="line">        singleLinkedList1.addNodeInOrder(heroNode5);</span><br><span class="line">        singleLinkedList1.addNodeInOrder(heroNode4);</span><br><span class="line">        singleLinkedList1.showNode();</span><br><span class="line">        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;翻转链表&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);</span><br><span class="line">        singleLinkedList1.reverseLinkedList();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;翻转链表&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">HeroNode&#123;no&#x3D;5, name&#x3D;&#39;张飞&#39;, nickName&#x3D;&#39;黑旋风&#39;&#125;</span><br><span class="line">HeroNode&#123;no&#x3D;4, name&#x3D;&#39;林冲&#39;, nickName&#x3D;&#39;豹子头&#39;&#125;</span><br><span class="line">HeroNode&#123;no&#x3D;3, name&#x3D;&#39;吴用&#39;, nickName&#x3D;&#39;智多星&#39;&#125;</span><br><span class="line">HeroNode&#123;no&#x3D;2, name&#x3D;&#39;卢俊义&#39;, nickName&#x3D;&#39;玉麒麟&#39;&#125;</span><br><span class="line">HeroNode&#123;no&#x3D;1, name&#x3D;&#39;宋江&#39;, nickName&#x3D;&#39;及时雨&#39;&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>线性结构-链表</title>
    <url>/2021/02/18/%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="线性结构-链表"><a href="#线性结构-链表" class="headerlink" title="线性结构-链表"></a>线性结构-链表</h1><h2 id="单链表的概念"><a href="#单链表的概念" class="headerlink" title="单链表的概念"></a>单链表的概念</h2><p>链表是有序的列表，但是它在内存中是存储如下</p>
<p><img src="https://i.loli.net/2021/02/18/h4D29ojT5kZNRSJ.png" alt="image.png"></p>
<p><code>小结</code>:</p>
<ol>
<li>链表是<code>以节点的方式来存储</code>,是链式存储</li>
<li><code>每个节点包含 data 域， next 域</code>：指向下一个节点.(head节点不存放任何数据，作用是表示单链表头)</li>
<li>如图：发现链表的各个节点<code>不一定是连续存储</code>.</li>
<li>链表分带头节点的链表和没有头节点的链表，根据实际的需求来确定</li>
</ol>
<p><img src="https://i.loli.net/2021/02/18/fQLTtpu2jg7hioC.png" alt="image.png"></p>
<h2 id="单链表的应用"><a href="#单链表的应用" class="headerlink" title="单链表的应用"></a>单链表的应用</h2><p><code>待完成目标：</code></p>
<ol>
<li>使用带head头的单向链表实现 –水浒英雄排行榜管理（class HeroNode,使用英雄节点表示英雄）</li>
<li>完成对英雄人物的增删改查操作</li>
<li>第一种方法在添加英雄时，直接添加到链表的尾部</li>
<li>第二种方式在添加英雄时，根据排名将英雄插入到指定位置(如果有这个排名，则添加失败，并给出提示)</li>
</ol>
<p><img src="https://i.loli.net/2021/02/18/UbWlJ2sPgXSBH5D.png" alt="image.png"></p>
<p>代码实现：</p>
<p>1.首先不考虑序号排序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;定义一个heroNode</span><br><span class="line">class HeroNode&#123;</span><br><span class="line">    &#x2F;&#x2F;编号</span><br><span class="line">    public int no;</span><br><span class="line">    &#x2F;&#x2F;英雄名字</span><br><span class="line">    public String name;</span><br><span class="line">    &#x2F;&#x2F;英雄昵称</span><br><span class="line">    public String nickName;</span><br><span class="line">    &#x2F;&#x2F;指向的下一个英雄</span><br><span class="line">    public HeroNode next;</span><br><span class="line"></span><br><span class="line">    public HeroNode(int no,String name,String nickName)&#123;</span><br><span class="line">        this.no &#x3D; no;</span><br><span class="line">        this.nickName &#x3D; nickName;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String  toString() &#123;</span><br><span class="line">        return &quot;HeroNode&#123;&quot; +</span><br><span class="line">                &quot;no&#x3D;&quot; + no +</span><br><span class="line">                &quot;, name&#x3D;&#39;&quot; + name + &#39;\&#39;&#39; +</span><br><span class="line">                &quot;, nickName&#x3D;&#39;&quot; + nickName + &#39;\&#39;&#39; +</span><br><span class="line">                &#39;&#125;&#39;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;定义一个单链表</span><br><span class="line">class SingleLinkedList&#123;</span><br><span class="line">    &#x2F;&#x2F;初始化一个头结点</span><br><span class="line">    private HeroNode head &#x3D; new HeroNode(0,&quot;&quot;,&quot;&quot;);</span><br><span class="line">    &#x2F;&#x2F;添加节点到单链表,(当不考虑编号顺序是，直接添加到最后)</span><br><span class="line">    public void addNode(HeroNode node)&#123;</span><br><span class="line">        &#x2F;&#x2F;找到最后的节点，lastNode.next &#x3D;&#x3D; null,将这个最后的节点的next指向这个节点</span><br><span class="line">        &#x2F;&#x2F;使用辅助指针</span><br><span class="line">        HeroNode temp &#x3D; head;</span><br><span class="line">        &#x2F;&#x2F;遍历链表，找到最后</span><br><span class="line">        while (true)&#123;</span><br><span class="line">            if(temp.next&#x3D;&#x3D;null)&#123;</span><br><span class="line">                &#x2F;&#x2F;说明到最后了</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;如果没有找到最后，temp往后移</span><br><span class="line">            temp &#x3D; temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;当退出while，temp就指向了链表最后,将新的节点放到temp的next域</span><br><span class="line">        temp.next &#x3D; node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;显示英雄链表</span><br><span class="line">    public void showNode() &#123;</span><br><span class="line">        &#x2F;&#x2F;判断链表是否为空</span><br><span class="line">        if(head.next&#x3D;&#x3D;null)&#123;</span><br><span class="line">            System.out.println(&quot;链表为空&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;头结点不能动，需要一个辅助变量来遍历</span><br><span class="line">        HeroNode temp &#x3D; head.next;</span><br><span class="line">        &#x2F;&#x2F;判断是否到链表最后,这里的temp代表的是整个节点，为空说明不存在这个节点，就说明到最后了</span><br><span class="line">        while (temp!&#x3D;null)&#123;</span><br><span class="line">            &#x2F;&#x2F;输出这个节点的信息</span><br><span class="line">            System.out.println(temp);</span><br><span class="line">            &#x2F;&#x2F;后移</span><br><span class="line">            temp &#x3D; temp.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;demo用例</span><br><span class="line">public class SingleLinkedListDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;测试</span><br><span class="line">        HeroNode heroNode1 &#x3D; new HeroNode(1,&quot;宋江&quot;,&quot;及时雨&quot;);</span><br><span class="line">        HeroNode heroNode2 &#x3D; new HeroNode(2,&quot;卢俊义&quot;,&quot;玉麒麟&quot;);</span><br><span class="line">        HeroNode heroNode3 &#x3D; new HeroNode(3,&quot;吴用&quot;,&quot;智多星&quot;);</span><br><span class="line">        HeroNode heroNode4 &#x3D; new HeroNode(4,&quot;林冲&quot;,&quot;豹子头&quot;);</span><br><span class="line">        HeroNode heroNode5 &#x3D; new HeroNode(5,&quot;张飞&quot;,&quot;黑旋风&quot;);</span><br><span class="line">        SingleLinkedList singleLinkedList &#x3D; new SingleLinkedList();</span><br><span class="line">        singleLinkedList.addNode(heroNode1);</span><br><span class="line">        singleLinkedList.addNode(heroNode2);</span><br><span class="line">        singleLinkedList.addNode(heroNode3);</span><br><span class="line">        singleLinkedList.addNode(heroNode4);</span><br><span class="line">        singleLinkedList.addNode(heroNode5);</span><br><span class="line">        singleLinkedList.showNode();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HeroNode&#123;no&#x3D;1, name&#x3D;&#39;宋江&#39;, nickName&#x3D;&#39;及时雨&#39;&#125;</span><br><span class="line">HeroNode&#123;no&#x3D;2, name&#x3D;&#39;卢俊义&#39;, nickName&#x3D;&#39;玉麒麟&#39;&#125;</span><br><span class="line">HeroNode&#123;no&#x3D;3, name&#x3D;&#39;吴用&#39;, nickName&#x3D;&#39;智多星&#39;&#125;</span><br><span class="line">HeroNode&#123;no&#x3D;4, name&#x3D;&#39;林冲&#39;, nickName&#x3D;&#39;豹子头&#39;&#125;</span><br><span class="line">HeroNode&#123;no&#x3D;5, name&#x3D;&#39;张飞&#39;, nickName&#x3D;&#39;黑旋风&#39;&#125;</span><br></pre></td></tr></table></figure>
<p>但是如果将1号和4号调换顺序之后就会出现问题（顺序会变成42315），毕竟没有排序</p>
<p>现在进行添加时自动排序部分代码的编写：</p>
<p>思路：</p>
<p>1.通过辅助变量找到新添加的位置</p>
<p>2.新的节点.next = 辅助变量.next</p>
<p>3.辅助变量.next = 新的节点</p>
<p>代码实现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package top.ryan.linkedlist;</span><br><span class="line"></span><br><span class="line">public class SingleLinkedListDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;测试</span><br><span class="line">        HeroNode heroNode1 &#x3D; new HeroNode(1,&quot;宋江&quot;,&quot;及时雨&quot;);</span><br><span class="line">        HeroNode heroNode2 &#x3D; new HeroNode(2,&quot;卢俊义&quot;,&quot;玉麒麟&quot;);</span><br><span class="line">        HeroNode heroNode3 &#x3D; new HeroNode(3,&quot;吴用&quot;,&quot;智多星&quot;);</span><br><span class="line">        HeroNode heroNode4 &#x3D; new HeroNode(4,&quot;林冲&quot;,&quot;豹子头&quot;);</span><br><span class="line">        HeroNode heroNode5 &#x3D; new HeroNode(5,&quot;张飞&quot;,&quot;黑旋风&quot;);</span><br><span class="line">        SingleLinkedList singleLinkedList &#x3D; new SingleLinkedList();</span><br><span class="line">        SingleLinkedList singleLinkedList1 &#x3D; new SingleLinkedList();</span><br><span class="line">        singleLinkedList.addNode(heroNode1);</span><br><span class="line">        singleLinkedList.addNode(heroNode3);</span><br><span class="line">        singleLinkedList.addNode(heroNode2);</span><br><span class="line">        singleLinkedList.addNode(heroNode5);</span><br><span class="line">        singleLinkedList.addNode(heroNode4);</span><br><span class="line">        singleLinkedList.showNode();</span><br><span class="line">        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);</span><br><span class="line">        singleLinkedList1.addNodeInOrder(heroNode1);</span><br><span class="line">        singleLinkedList1.addNodeInOrder(heroNode3);</span><br><span class="line">        singleLinkedList1.addNodeInOrder(heroNode2);</span><br><span class="line">        singleLinkedList1.addNodeInOrder(heroNode5);</span><br><span class="line">        singleLinkedList1.addNodeInOrder(heroNode4);</span><br><span class="line">        singleLinkedList1.showNode();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;定义一个单链表</span><br><span class="line">class SingleLinkedList&#123;</span><br><span class="line">    &#x2F;&#x2F;初始化一个头结点</span><br><span class="line">    private HeroNode head &#x3D; new HeroNode(0,&quot;&quot;,&quot;&quot;);</span><br><span class="line">    &#x2F;&#x2F;添加节点到单链表,(当不考虑编号顺序是，直接添加到最后)</span><br><span class="line">    public void addNode(HeroNode node)&#123;</span><br><span class="line">        &#x2F;&#x2F;找到最后的节点，lastNode.next &#x3D;&#x3D; null,将这个最后的节点的next指向这个节点</span><br><span class="line">        &#x2F;&#x2F;使用辅助指针</span><br><span class="line">        HeroNode temp &#x3D; head;</span><br><span class="line">        &#x2F;&#x2F;遍历链表，找到最后</span><br><span class="line">        while (true)&#123;</span><br><span class="line">            if(temp.next&#x3D;&#x3D;null)&#123;</span><br><span class="line">                &#x2F;&#x2F;说明到最后了</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;如果没有找到最后，temp往后移</span><br><span class="line">            temp &#x3D; temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;当退出while，temp就指向了链表最后,将新的节点放到temp的next域</span><br><span class="line">        temp.next &#x3D; node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void addNodeInOrder(HeroNode node)&#123;</span><br><span class="line">        &#x2F;&#x2F;找到最后的节点，lastNode.next &#x3D;&#x3D; null,将这个最后的节点的next指向这个节点</span><br><span class="line">        &#x2F;&#x2F;使用辅助指针</span><br><span class="line">        HeroNode temp &#x3D; head;</span><br><span class="line">        &#x2F;&#x2F;遍历链表，找到最后</span><br><span class="line">        while (true)&#123;</span><br><span class="line">            if(temp.next&#x3D;&#x3D;null)&#123;</span><br><span class="line">                &#x2F;&#x2F;说明到最后了</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            if (temp.next.no &gt; node.no) &#123;</span><br><span class="line">                &#x2F;&#x2F;找到位置了</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;如果没有找到最后，temp往后移</span><br><span class="line">            temp &#x3D; temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;当退出while，temp找到了位置，将这个节点的next指向temp.next,然后temp.next 在指向node</span><br><span class="line">        node.next &#x3D; temp.next;</span><br><span class="line">        temp.next &#x3D; node;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;显示英雄链表</span><br><span class="line">    public void showNode() &#123;</span><br><span class="line">        &#x2F;&#x2F;判断链表是否为空</span><br><span class="line">        if(head.next&#x3D;&#x3D;null)&#123;</span><br><span class="line">            System.out.println(&quot;链表为空&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;头结点不能动，需要一个辅助变量来遍历</span><br><span class="line">        HeroNode temp &#x3D; head.next;</span><br><span class="line">        &#x2F;&#x2F;判断是否到链表最后,这里的temp代表的是整个节点，为空说明不存在这个节点，就说明到最后了</span><br><span class="line">        while (temp!&#x3D;null)&#123;</span><br><span class="line">            &#x2F;&#x2F;输出这个节点的信息</span><br><span class="line">            System.out.println(temp);</span><br><span class="line">            &#x2F;&#x2F;后移</span><br><span class="line">            temp &#x3D; temp.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;定义一个heroNode</span><br><span class="line">class HeroNode&#123;</span><br><span class="line">    &#x2F;&#x2F;编号</span><br><span class="line">    public int no;</span><br><span class="line">    &#x2F;&#x2F;英雄名字</span><br><span class="line">    public String name;</span><br><span class="line">    &#x2F;&#x2F;英雄昵称</span><br><span class="line">    public String nickName;</span><br><span class="line">    &#x2F;&#x2F;指向的下一个英雄</span><br><span class="line">    public HeroNode next;</span><br><span class="line"></span><br><span class="line">    public HeroNode(int no,String name,String nickName)&#123;</span><br><span class="line">        this.no &#x3D; no;</span><br><span class="line">        this.nickName &#x3D; nickName;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String  toString() &#123;</span><br><span class="line">        return &quot;HeroNode&#123;&quot; +</span><br><span class="line">                &quot;no&#x3D;&quot; + no +</span><br><span class="line">                &quot;, name&#x3D;&#39;&quot; + name + &#39;\&#39;&#39; +</span><br><span class="line">                &quot;, nickName&#x3D;&#39;&quot; + nickName + &#39;\&#39;&#39; +</span><br><span class="line">                &#39;&#125;&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HeroNode&#123;no&#x3D;1, name&#x3D;&#39;宋江&#39;, nickName&#x3D;&#39;及时雨&#39;&#125;</span><br><span class="line">HeroNode&#123;no&#x3D;3, name&#x3D;&#39;吴用&#39;, nickName&#x3D;&#39;智多星&#39;&#125;</span><br><span class="line">HeroNode&#123;no&#x3D;2, name&#x3D;&#39;卢俊义&#39;, nickName&#x3D;&#39;玉麒麟&#39;&#125;</span><br><span class="line">HeroNode&#123;no&#x3D;5, name&#x3D;&#39;张飞&#39;, nickName&#x3D;&#39;黑旋风&#39;&#125;</span><br><span class="line">HeroNode&#123;no&#x3D;4, name&#x3D;&#39;林冲&#39;, nickName&#x3D;&#39;豹子头&#39;&#125;</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">HeroNode&#123;no&#x3D;1, name&#x3D;&#39;宋江&#39;, nickName&#x3D;&#39;及时雨&#39;&#125;</span><br><span class="line">HeroNode&#123;no&#x3D;2, name&#x3D;&#39;卢俊义&#39;, nickName&#x3D;&#39;玉麒麟&#39;&#125;</span><br><span class="line">HeroNode&#123;no&#x3D;3, name&#x3D;&#39;吴用&#39;, nickName&#x3D;&#39;智多星&#39;&#125;</span><br><span class="line">HeroNode&#123;no&#x3D;4, name&#x3D;&#39;林冲&#39;, nickName&#x3D;&#39;豹子头&#39;&#125;</span><br><span class="line">HeroNode&#123;no&#x3D;5, name&#x3D;&#39;张飞&#39;, nickName&#x3D;&#39;黑旋风&#39;&#125;</span><br></pre></td></tr></table></figure>
<p>问题又来了，在这里可以添加重复的数据，如何可以控制他不能添加重复数据，再有重复数据时给与友好提示呢，只需要更改一下<code>addNodeInorder</code>这个方法.</p>
<p>使用一个标识flag,来判断链表是否已经存在这个需要添加进链表的值就行了</p>
<p>代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void addNodeInOrder(HeroNode node)&#123;</span><br><span class="line">       &#x2F;&#x2F;找到最后的节点，lastNode.next &#x3D;&#x3D; null,将这个最后的节点的next指向这个节点</span><br><span class="line">       &#x2F;&#x2F;使用辅助指针</span><br><span class="line">       HeroNode temp &#x3D; head;</span><br><span class="line">       boolean flag &#x3D; false;</span><br><span class="line">       &#x2F;&#x2F;遍历链表，找到最后</span><br><span class="line">       while (true)&#123;</span><br><span class="line">           if(temp.next&#x3D;&#x3D;null)&#123;</span><br><span class="line">               &#x2F;&#x2F;说明到最后了</span><br><span class="line">               break;</span><br><span class="line">           &#125;</span><br><span class="line">           if (temp.next.no &gt; node.no) &#123;</span><br><span class="line">               &#x2F;&#x2F;找到位置了</span><br><span class="line">               break;</span><br><span class="line">           &#125;else if(temp.next.no &#x3D;&#x3D; head.no)&#123;</span><br><span class="line">               flag &#x3D; true;</span><br><span class="line">               break;</span><br><span class="line">           &#125;</span><br><span class="line">           &#x2F;&#x2F;如果没有找到最后，temp往后移</span><br><span class="line">           temp &#x3D; temp.next;</span><br><span class="line">       &#125;</span><br><span class="line">       if(flag)&#123;</span><br><span class="line">           throw new RuntimeException(&quot;数据已经添加过了，不能重复添加&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">       &#x2F;&#x2F;当退出while，temp找到了位置，将这个节点的next指向temp.next,然后temp.next 在指向node</span><br><span class="line">       node.next &#x3D; temp.next;</span><br><span class="line">       temp.next &#x3D; node;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>总的代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package top.ryan.linkedlist;</span><br><span class="line"></span><br><span class="line">import javax.xml.soap.Node;</span><br><span class="line"></span><br><span class="line">public class SingleLinkedListDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;测试</span><br><span class="line">        HeroNode heroNode1 &#x3D; new HeroNode(1,&quot;宋江&quot;,&quot;及时雨&quot;);</span><br><span class="line">        HeroNode heroNode2 &#x3D; new HeroNode(2,&quot;卢俊义&quot;,&quot;玉麒麟&quot;);</span><br><span class="line">        HeroNode heroNode3 &#x3D; new HeroNode(3,&quot;吴用&quot;,&quot;智多星&quot;);</span><br><span class="line">        HeroNode heroNode4 &#x3D; new HeroNode(4,&quot;林冲&quot;,&quot;豹子头&quot;);</span><br><span class="line">        HeroNode heroNode5 &#x3D; new HeroNode(5,&quot;张飞&quot;,&quot;黑旋风&quot;);</span><br><span class="line">        SingleLinkedList singleLinkedList &#x3D; new SingleLinkedList();</span><br><span class="line">        SingleLinkedList singleLinkedList1 &#x3D; new SingleLinkedList();</span><br><span class="line">        singleLinkedList.addNode(heroNode1);</span><br><span class="line">        singleLinkedList.addNode(heroNode3);</span><br><span class="line">        singleLinkedList.addNode(heroNode2);</span><br><span class="line">        singleLinkedList.addNode(heroNode5);</span><br><span class="line">        singleLinkedList.addNode(heroNode4);</span><br><span class="line">        singleLinkedList.showNode();</span><br><span class="line">        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);</span><br><span class="line">        singleLinkedList1.addNodeInOrder(heroNode1);</span><br><span class="line">        singleLinkedList1.addNodeInOrder(heroNode3);</span><br><span class="line">        singleLinkedList1.addNodeInOrder(heroNode2);</span><br><span class="line">        singleLinkedList1.addNodeInOrder(heroNode5);</span><br><span class="line">        singleLinkedList1.addNodeInOrder(heroNode4);</span><br><span class="line">        singleLinkedList1.showNode();</span><br><span class="line">        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);</span><br><span class="line">        HeroNode heroNode6 &#x3D; new HeroNode(1,&quot;宋江&quot;,&quot;及时雨1111&quot;);</span><br><span class="line">        singleLinkedList1.updateNode(heroNode6);</span><br><span class="line">        singleLinkedList1.showNode();</span><br><span class="line">        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);</span><br><span class="line">        HeroNode node &#x3D; new HeroNode(3,&quot;&quot;,&quot;&quot;);</span><br><span class="line">        singleLinkedList1.deleteNode(node);</span><br><span class="line">        singleLinkedList1.showNode();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;定义一个单链表</span><br><span class="line">class SingleLinkedList&#123;</span><br><span class="line">    &#x2F;&#x2F;初始化一个头结点</span><br><span class="line">    private HeroNode head &#x3D; new HeroNode(0,&quot;&quot;,&quot;&quot;);</span><br><span class="line">    &#x2F;&#x2F;添加节点到单链表,(当不考虑编号顺序是，直接添加到最后)</span><br><span class="line">    public void addNode(HeroNode node)&#123;</span><br><span class="line">        &#x2F;&#x2F;找到最后的节点，lastNode.next &#x3D;&#x3D; null,将这个最后的节点的next指向这个节点</span><br><span class="line">        &#x2F;&#x2F;使用辅助指针</span><br><span class="line">        HeroNode temp &#x3D; head;</span><br><span class="line">        &#x2F;&#x2F;遍历链表，找到最后</span><br><span class="line">        while (true)&#123;</span><br><span class="line">            if(temp.next&#x3D;&#x3D;null)&#123;</span><br><span class="line">                &#x2F;&#x2F;说明到最后了</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;如果没有找到最后，temp往后移</span><br><span class="line">            temp &#x3D; temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;当退出while，temp就指向了链表最后,将新的节点放到temp的next域</span><br><span class="line">        temp.next &#x3D; node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void addNodeInOrder(HeroNode node)&#123;</span><br><span class="line">        &#x2F;&#x2F;找到最后的节点，lastNode.next &#x3D;&#x3D; null,将这个最后的节点的next指向这个节点</span><br><span class="line">        &#x2F;&#x2F;使用辅助指针</span><br><span class="line">        HeroNode temp &#x3D; head;</span><br><span class="line">        boolean flag &#x3D; false;</span><br><span class="line">        &#x2F;&#x2F;遍历链表，找到最后</span><br><span class="line">        while (true)&#123;</span><br><span class="line">            if(temp.next&#x3D;&#x3D;null)&#123;</span><br><span class="line">                &#x2F;&#x2F;说明到最后了</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            if (temp.next.no &gt; node.no) &#123;</span><br><span class="line">                &#x2F;&#x2F;找到位置了</span><br><span class="line">                break;</span><br><span class="line">            &#125;else if(temp.next.no &#x3D;&#x3D; head.no)&#123;</span><br><span class="line">                flag &#x3D; true;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;如果没有找到最后，temp往后移</span><br><span class="line">            temp &#x3D; temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        if(flag)&#123;</span><br><span class="line">            throw new RuntimeException(&quot;数据已经添加过了，不能重复添加&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;当退出while，temp找到了位置，将这个节点的next指向temp.next,然后temp.next 在指向node</span><br><span class="line">        node.next &#x3D; temp.next;</span><br><span class="line">        temp.next &#x3D; node;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;显示英雄链表</span><br><span class="line">    public void showNode() &#123;</span><br><span class="line">        &#x2F;&#x2F;判断链表是否为空</span><br><span class="line">        if(head.next&#x3D;&#x3D;null)&#123;</span><br><span class="line">            System.out.println(&quot;链表为空&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;头结点不能动，需要一个辅助变量来遍历</span><br><span class="line">        HeroNode temp &#x3D; head.next;</span><br><span class="line">        &#x2F;&#x2F;判断是否到链表最后,这里的temp代表的是整个节点，为空说明不存在这个节点，就说明到最后了</span><br><span class="line">        while (temp!&#x3D;null)&#123;</span><br><span class="line">            &#x2F;&#x2F;输出这个节点的信息</span><br><span class="line">            System.out.println(temp);</span><br><span class="line">            &#x2F;&#x2F;后移</span><br><span class="line">            temp &#x3D; temp.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;修改英雄，根据no</span><br><span class="line">    public void updateNode(HeroNode node)&#123;</span><br><span class="line">        &#x2F;&#x2F;判空</span><br><span class="line">        if(head.next&#x3D;&#x3D;null)&#123;</span><br><span class="line">            System.out.println(&quot;链表为空&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;定义辅助变量</span><br><span class="line">        HeroNode temp &#x3D; head.next;</span><br><span class="line">        &#x2F;&#x2F;表示未找到该节点</span><br><span class="line">        boolean flag &#x3D; false;</span><br><span class="line">        while (temp!&#x3D;null)&#123;</span><br><span class="line">            if(temp.no &#x3D;&#x3D; node.no)&#123;</span><br><span class="line">                &#x2F;&#x2F;找到了</span><br><span class="line">                flag &#x3D; true;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;后移</span><br><span class="line">            temp &#x3D; temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        if(!flag)&#123;</span><br><span class="line">            System.out.printf(&quot;没找到%d的节点，不能修改\n&quot;,node.no);</span><br><span class="line">        &#125;</span><br><span class="line">        temp.nickName &#x3D; node.nickName;</span><br><span class="line">        temp.name &#x3D; node.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 删除节点</span><br><span class="line">     * @param node</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void deleteNode(HeroNode node)&#123;</span><br><span class="line">        &#x2F;&#x2F;判空</span><br><span class="line">        if(head.next&#x3D;&#x3D;null)&#123;</span><br><span class="line">            System.out.println(&quot;链表为空&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;定义辅助变量</span><br><span class="line">        HeroNode temp &#x3D; head;</span><br><span class="line">        boolean flag &#x3D; false;</span><br><span class="line">        while (temp.next!&#x3D;null)&#123;</span><br><span class="line">             if(temp.next.no &#x3D;&#x3D; node.no)&#123;</span><br><span class="line">                 flag &#x3D; true;</span><br><span class="line">                 break;</span><br><span class="line">             &#125;</span><br><span class="line">            &#x2F;&#x2F;后移</span><br><span class="line">            temp &#x3D; temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        if(!flag)&#123;</span><br><span class="line">            System.out.printf(&quot;没有编号为%d的该节点&quot;,node.no);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;删除节点</span><br><span class="line">        temp.next &#x3D; temp.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;定义一个heroNode</span><br><span class="line">class HeroNode&#123;</span><br><span class="line">    &#x2F;&#x2F;编号</span><br><span class="line">    public int no;</span><br><span class="line">    &#x2F;&#x2F;英雄名字</span><br><span class="line">    public String name;</span><br><span class="line">    &#x2F;&#x2F;英雄昵称</span><br><span class="line">    public String nickName;</span><br><span class="line">    &#x2F;&#x2F;指向的下一个英雄</span><br><span class="line">    public HeroNode next;</span><br><span class="line"></span><br><span class="line">    public HeroNode(int no,String name,String nickName)&#123;</span><br><span class="line">        this.no &#x3D; no;</span><br><span class="line">        this.nickName &#x3D; nickName;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String  toString() &#123;</span><br><span class="line">        return &quot;HeroNode&#123;&quot; +</span><br><span class="line">                &quot;no&#x3D;&quot; + no +</span><br><span class="line">                &quot;, name&#x3D;&#39;&quot; + name + &#39;\&#39;&#39; +</span><br><span class="line">                &quot;, nickName&#x3D;&#39;&quot; + nickName + &#39;\&#39;&#39; +</span><br><span class="line">                &#39;&#125;&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
</search>
